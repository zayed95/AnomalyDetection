!function(){"use strict";var e={randomUUID:"undefined"!==typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};let t;const o=new Uint8Array(16);const s=[];for(let m=0;m<256;++m)s.push((m+256).toString(16).slice(1));function n(e,t=0){return(s[e[t+0]]+s[e[t+1]]+s[e[t+2]]+s[e[t+3]]+"-"+s[e[t+4]]+s[e[t+5]]+"-"+s[e[t+6]]+s[e[t+7]]+"-"+s[e[t+8]]+s[e[t+9]]+"-"+s[e[t+10]]+s[e[t+11]]+s[e[t+12]]+s[e[t+13]]+s[e[t+14]]+s[e[t+15]]).toLowerCase()}function r(e,s,r){const u=(e=e||{}).random??e.rng?.()??function(){if(!t){if("undefined"===typeof crypto||!crypto.getRandomValues)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");t=crypto.getRandomValues.bind(crypto)}return t(o)}();if(u.length<16)throw new Error("Random bytes length must be >= 16");if(u[6]=15&u[6]|64,u[8]=63&u[8]|128,s){if((r=r||0)<0||r+16>s.length)throw new RangeError(`UUID byte range ${r}:${r+15} is out of buffer bounds`);for(let e=0;e<16;++e)s[r+e]=u[e];return s}return n(u)}var u=function(t,o,s){return!e.randomUUID||o||t?r(t,o,s):e.randomUUID()};let i=function(e){return e.READY="READY",e}({}),l=function(e){return e.LOG_EVENT="LOG_EVENT",e.SHUTDOWN="SHUTDOWN",e}({});const a="../ajax-api/3.0/mlflow/ui-telemetry";class h{constructor(){this.queue=[],this.flushTimer=null,this.startFlushTimer()}enqueue(e){null!==this.flushTimer&&this.queue.push(e)}startFlushTimer(){null===this.flushTimer&&this.scheduleNextFlush()}scheduleNextFlush(){this.flushTimer=self.setTimeout((()=>{this.flush(),this.scheduleNextFlush()}),3e4)}stopFlushTimer(){null!==this.flushTimer&&(self.clearTimeout(this.flushTimer),this.flushTimer=null),this.flush()}async flush(){if(0===this.queue.length||!navigator.onLine)return;const e=[...this.queue];this.queue=[];try{const t=await fetch(a,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({records:e})});if(!t.ok)return console.error(`[LogQueue] Failed to upload batch: ${t.status}`),void this.queue.unshift(...e);"disabled"===(await t.json()).status&&this.destroy()}catch(t){console.error("[LogQueue] Error uploading batch:",t),this.queue.unshift(...e)}}clear(){this.queue=[]}destroy(){this.stopFlushTimer(),this.queue=[]}}const c=self;const d=new class{constructor(){this.config=async function(){try{const e=await fetch(a,{method:"GET",headers:{"Content-Type":"application/json"}});if(!e.ok)throw new Error(`Failed to fetch config: ${e.status}`);return await e.json()}catch(e){return console.error("[TelemetryWorker] Failed to fetch config:",e),null}}(),this.sessionId=u(),this.logQueue=new h,this.samplingValue=100*Math.random()}async addLogToQueue(e){var t,o,s,n,r;const u=await this.config;if(!u||null===(t=u.disable_ui_telemetry)||void 0===t||t)return;if(!(this.samplingValue<(null!==(o=u.ui_rollout_percentage)&&void 0!==o?o:0)))return;(null===(s=u.disable_ui_events)||void 0===s?void 0:s.includes(null!==(n=null===(r=e.params)||void 0===r?void 0:r.componentId)&&void 0!==n?n:""))||this.logQueue.enqueue({...e,session_id:this.sessionId})}destroy(){this.logQueue.destroy()}};function f(e){const t=e.data;switch(t.type){case l.LOG_EVENT:d.addLogToQueue(t.payload).catch((e=>{console.error("[TelemetryWorker] Error logging event:",e)}));break;case l.SHUTDOWN:d.destroy(),c.close()}}c.onconnect=e=>{const t=e.ports[0];t.onmessage=f,t.postMessage({type:i.READY})}}();